import java.util.*;
import java.awt.Point;
import java.util.LinkedList;


public class YourMazeWithPath {


    private InputGraphicMaze maze; //Maze to traverse
    private int R, C; //Amount of Row and Column
    private boolean [][] Visited; //to store visited
    private Point[] Parent; // array of points for parent
    private Point End; //final point of path
    /**
     * Create maze and find a path through the maze
     * will use Recursive Depth First Search
     */
    private YourMazeWithPath() {
       // an R rows x C columns maze
        maze = new InputGraphicMaze();
        //Global variables to hold maze size [ROW][COLUMN]
        R=maze.Rows(); C=maze.Cols();
        //Global Boolean array to store whether maze cell has been searched
        Visited = new boolean[R+1][C+1]; //V has extra space to top and left [zero values]
        // Path holds the cells of the path
        LinkedList<Point> Path = new LinkedList<Point>();
        // Create the path
        CreatePath(maze, 1, 1, Path);
        // show the path in the maze
        maze.showPath(Path);
    }
/**
 * some math! grid vectors for up down left and right
 * Up = [ROW-1][COLUMN]
 * Down = [ROW+1][COLUMN]
 * Left = [ROW][COLUMN-1]
 * Right = [ROW][COLUMN+1]
 * LINEAR POSITION [(ROW-1)*TOTAL_C + COLUMN]
 */


    /**
     *
     * @param maze maze generated by InputGraphicMaze class
     * @param srow starting cell row value, not overflow safe but can be changed
     * @param scol starting cell column value, not overflow safe but can be changed
     * @param L LinkedList for start-to-finish path
     * @return
     */
    private void CreatePath(InputGraphicMaze maze, int srow, int scol, LinkedList<Point> L) {
        int R=maze.Rows(), C=maze.Cols(); //initialize GLOBAL Maze Size [ROW] [COLUMN] variables
        Parent = new Point [R*C+1]; //initialize GLOBAL linear Array to store parents
        RecursiveDFS(new Point(srow,scol), new Point(0,0)); //call recursion
        //Gather PATH, should probably throw this to it's own method
        while (!End.equals(Parent[(srow-1)*C+scol])) {
            int r=(int) End.getX(); int c=(int) End.getY();
            L.addFirst(End); End=Parent[(r-1)*C+c];
        }
    }

    /**
     * Recursively search the maze grid, relies on maze.can_go(row,column,'direction') from InputGraphicMaze
     * @param iterator Cell currently being traversed
     * @param parent Parent of cell currently being traversed
     */
    private void RecursiveDFS(Point iterator, Point parent){
        /**
         * -Visit-
         * Set temporary [row][column] variables.
         * Set GLOBAL Parent[] (linear index).
         * Mark cell in GLOBAL Visited[r][c].
         */
        int r =(int) iterator.getX(), c =(int) iterator.getY();
        Parent[(r-1)*C+c]= parent;
        Visited[r][c]=true;
        /**
         * Traverse UP,DOWN,LEFT,RIGHT (in lieu of adjacency list or matrix).
         * Since return walks back the recursion chain, adding &&(End==null) and
         * eliminating loops ensures stack safety. All subsequent if's fail and the stack frames
         * each complete in turn. This is why End is a global variable.
         */
        if(r==R&&c==C){
            End=iterator;//check if at end
        } else {
            if ((r > 1) && (!Visited[r - 1][c]) && (maze.can_go(r, c, 'U')) && (End == null)) {
                RecursiveDFS(new Point(r - 1, c), iterator);
            }
            if ((r < R) && (!Visited[r + 1][c]) && (maze.can_go(r, c, 'D')) && (End == null)) {
                RecursiveDFS(new Point(r + 1, c), iterator);
            }
            if ((c > 1) && (!Visited[r][c - 1]) && (maze.can_go(r, c, 'L')) && (End == null)) {
                RecursiveDFS(new Point(r, c - 1), iterator);
            }
            if ((c < C) && (!Visited[r][c + 1]) && (maze.can_go(r, c, 'R')) && (End == null)) {
                RecursiveDFS(new Point(r, c + 1), iterator);
            }
        }
    }

    /**
     * Main method
     * @param args no args
     */
    public static void main(String[] args)
    {new YourMazeWithPath();}


}


